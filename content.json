{"meta":{"title":"Mason's blog","subtitle":null,"description":null,"author":"Mason Shin","url":"https://minsooshin.github.io"},"pages":[],"posts":[{"title":"Contains Duplicate","slug":"Contains-Duplicate","date":"2017-05-03T16:39:30.000Z","updated":"2017-05-03T16:44:02.000Z","comments":true,"path":"2017/05/03/Contains-Duplicate/","link":"","permalink":"https://minsooshin.github.io/2017/05/03/Contains-Duplicate/","excerpt":"","text":"Source: leetcode 217. Contains Duplicate Q. Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Solutions123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */export default function containsDuplicate (nums) &#123; const seen = new Set() for (let i = 0; i &lt; nums.length; i++) &#123; if (seen.has(nums[i])) &#123; return true &#125; else &#123; seen.add(nums[i]) &#125; &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"https://minsooshin.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"}]},{"title":"Reverse String","slug":"Reverse-String","date":"2017-05-03T16:22:02.000Z","updated":"2017-05-03T16:41:21.000Z","comments":true,"path":"2017/05/03/Reverse-String/","link":"","permalink":"https://minsooshin.github.io/2017/05/03/Reverse-String/","excerpt":"","text":"Source: leetcode 344. Reverse String Q. Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh” Solution 1: Using two pointers1234567891011121314/** * @param &#123;string&#125; s * @return &#123;string&#125; */export default function reverseString (s) &#123; const arr = s.split('') const half = arr.length / 2 | 0 for (let i = 0; i &lt; half; i++) &#123; const temp = arr[i] arr[i] = arr[arr.length - i - 1] arr[s.length - i - 1] = temp &#125; return arr.join('')&#125; Solution 2:: Using reverse array1234567891011/** * @param &#123;string&#125; s * @return &#123;string&#125; */export default function reverseString (s) &#123; let reversed = '' for (let i = s.length - 1; i &gt;= 0; i--) &#123; reversed += s.charAt(i) &#125; return reversed&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"string","slug":"string","permalink":"https://minsooshin.github.io/tags/string/"},{"name":"two pointers","slug":"two-pointers","permalink":"https://minsooshin.github.io/tags/two-pointers/"}]},{"title":"Single Number","slug":"Single-Number","date":"2017-05-02T21:49:32.000Z","updated":"2017-05-02T22:24:04.000Z","comments":true,"path":"2017/05/02/Single-Number/","link":"","permalink":"https://minsooshin.github.io/2017/05/02/Single-Number/","excerpt":"","text":"Source: leetcode 136. Single Number Q. Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Solution 1: with using extra memory123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */export default function singleNumber (nums) &#123; const seen = new Set() for (let i = 0; i &lt; nums.length; i++) &#123; if (seen.has(nums[i])) &#123; seen.delete(nums[i]) &#125; else &#123; seen.add(nums[i]) &#125; &#125; return seen.values().next().value&#125; Solution 2: without using extra memory1234567/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */export default function singleNumber (nums) &#123; return nums.reduce((curr, prev) =&gt; curr ^ prev)&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"},{"name":"bit manipulation","slug":"bit-manipulation","permalink":"https://minsooshin.github.io/tags/bit-manipulation/"}]},{"title":"Two Sum","slug":"Two-Sum","date":"2017-05-02T20:58:00.000Z","updated":"2017-05-02T21:58:25.000Z","comments":true,"path":"2017/05/02/Two-Sum/","link":"","permalink":"https://minsooshin.github.io/2017/05/02/Two-Sum/","excerpt":"","text":"Source: leetcode 1. Two Sum Q. Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213141516/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */export default function twoSum (nums, target) &#123; const seen = &#123;&#125; for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i] if (seen[diff] !== undefined) &#123; return [seen[diff], i] &#125; else &#123; seen[nums[i]] = i &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"https://minsooshin.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"}]}]}
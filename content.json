{"meta":{"title":"Mason's blog","subtitle":null,"description":null,"author":"Mason Shin","url":"https://minsooshin.github.io"},"pages":[],"posts":[{"title":"Search Insert Position","slug":"Search-Insert-Position","date":"2017-05-03T20:29:37.000Z","updated":"2017-05-04T00:05:25.000Z","comments":true,"path":"2017/05/03/Search-Insert-Position/","link":"","permalink":"https://minsooshin.github.io/2017/05/03/Search-Insert-Position/","excerpt":"","text":"Source: leetcode 35. Search Insert Position Q. Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1, 3, 5, 6], 5 &rarr; 2[1, 3, 5, 6], 2 &rarr; 1[1, 3, 5, 6], 7 &rarr; 4[1, 3, 5, 6], 0 &rarr; 0 Answer1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */export default function searchInsert (nums, target) &#123; let low = 0 let high = nums.length - 1 while (low &lt;= high) &#123; const mid = (low + high) / 2 | 0 if (nums[mid] === target) &#123; return mid &#125; else if (nums[mid] &gt; target) &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return low&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"https://minsooshin.github.io/tags/array/"},{"name":"binary search","slug":"binary-search","permalink":"https://minsooshin.github.io/tags/binary-search/"}]},{"title":"Contains Duplicate","slug":"Contains-Duplicate","date":"2017-05-03T16:39:30.000Z","updated":"2017-05-04T00:05:11.000Z","comments":true,"path":"2017/05/03/Contains-Duplicate/","link":"","permalink":"https://minsooshin.github.io/2017/05/03/Contains-Duplicate/","excerpt":"","text":"Source: leetcode 217. Contains Duplicate Q. Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Answer123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */export default function containsDuplicate (nums) &#123; const seen = new Set() for (let i = 0; i &lt; nums.length; i++) &#123; if (seen.has(nums[i])) &#123; return true &#125; else &#123; seen.add(nums[i]) &#125; &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"},{"name":"array","slug":"array","permalink":"https://minsooshin.github.io/tags/array/"}]},{"title":"Reverse String","slug":"Reverse-String","date":"2017-05-03T16:22:02.000Z","updated":"2017-05-03T16:52:27.000Z","comments":true,"path":"2017/05/03/Reverse-String/","link":"","permalink":"https://minsooshin.github.io/2017/05/03/Reverse-String/","excerpt":"","text":"Source: leetcode 344. Reverse String Q. Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh” Answer 1: Using two pointers1234567891011121314/** * @param &#123;string&#125; s * @return &#123;string&#125; */export default function reverseString (s) &#123; const arr = s.split('') const half = arr.length / 2 | 0 for (let i = 0; i &lt; half; i++) &#123; const temp = arr[i] arr[i] = arr[arr.length - i - 1] arr[s.length - i - 1] = temp &#125; return arr.join('')&#125; Answer 2: Using simple string concatenation1234567891011/** * @param &#123;string&#125; s * @return &#123;string&#125; */export default function reverseString (s) &#123; let reversed = '' for (let i = s.length - 1; i &gt;= 0; i--) &#123; reversed += s.charAt(i) &#125; return reversed&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"string","slug":"string","permalink":"https://minsooshin.github.io/tags/string/"},{"name":"two pointers","slug":"two-pointers","permalink":"https://minsooshin.github.io/tags/two-pointers/"}]},{"title":"Single Number","slug":"Single-Number","date":"2017-05-02T21:49:32.000Z","updated":"2017-05-03T16:52:36.000Z","comments":true,"path":"2017/05/02/Single-Number/","link":"","permalink":"https://minsooshin.github.io/2017/05/02/Single-Number/","excerpt":"","text":"Source: leetcode 136. Single Number Q. Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Answer 1: with using extra memory123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */export default function singleNumber (nums) &#123; const seen = new Set() for (let i = 0; i &lt; nums.length; i++) &#123; if (seen.has(nums[i])) &#123; seen.delete(nums[i]) &#125; else &#123; seen.add(nums[i]) &#125; &#125; return seen.values().next().value&#125; Answer 2: without using extra memory1234567/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */export default function singleNumber (nums) &#123; return nums.reduce((curr, prev) =&gt; curr ^ prev)&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"},{"name":"bit manipulation","slug":"bit-manipulation","permalink":"https://minsooshin.github.io/tags/bit-manipulation/"}]},{"title":"Two Sum","slug":"Two-Sum","date":"2017-05-02T20:58:00.000Z","updated":"2017-05-03T16:52:40.000Z","comments":true,"path":"2017/05/02/Two-Sum/","link":"","permalink":"https://minsooshin.github.io/2017/05/02/Two-Sum/","excerpt":"","text":"Source: leetcode 1. Two Sum Q. Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Answer12345678910111213141516/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */export default function twoSum (nums, target) &#123; const seen = &#123;&#125; for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i] if (seen[diff] !== undefined) &#123; return [seen[diff], i] &#125; else &#123; seen[nums[i]] = i &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://minsooshin.github.io/categories/leetcode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"https://minsooshin.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"https://minsooshin.github.io/tags/hash-table/"},{"name":"array","slug":"array","permalink":"https://minsooshin.github.io/tags/array/"}]}]}